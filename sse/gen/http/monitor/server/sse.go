// Code generated by goa v3.25.3, DO NOT EDIT.
//
// sse
//
// Command:
// $ goa gen goa.design/examples/sse/design

package server

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"

	monitor "goa.design/examples/sse/gen/monitor"
)

// MonitorServerStream implements the monitor.MonitorServerStream interface
// using Server-Sent Events.
type MonitorServerStream struct {
	// once ensures the headers are written once.
	once sync.Once
	// w is the HTTP response writer used to send the SSE events.
	w http.ResponseWriter
	// r is the HTTP request.
	r *http.Request
}

// Send Send streams instances of "monitor.Usage" to the "monitor" endpoint SSE
// connection.
func (s *MonitorServerStream) Send(v *monitor.Usage) error {
	return s.SendWithContext(context.Background(), v)
}

// SendWithContext SendWithContext streams instances of "monitor.Usage" to the
// "monitor" endpoint SSE connection with context.
func (s *MonitorServerStream) SendWithContext(ctx context.Context, v *monitor.Usage) error {
	s.once.Do(func() {
		header := s.w.Header()
		if header.Get("Content-Type") == "" {
			header.Set("Content-Type", "text/event-stream")
		}
		if header.Get("Cache-Control") == "" {
			header.Set("Cache-Control", "no-cache")
		}
		if header.Get("Connection") == "" {
			header.Set("Connection", "keep-alive")
		}
		s.w.WriteHeader(http.StatusOK)
	})
	res := v

	var data string
	var payload any
	body := NewMonitorResponseBody(res)
	payload = body
	switch v := payload.(type) {
	case nil:
		data = "null"
	case string:
		data = v
	case []byte:
		data = string(v)
	case bool:
		if v {
			data = "true"
		} else {
			data = "false"
		}
	case int:
		data = fmt.Sprintf("%d", v)
	case int8:
		data = fmt.Sprintf("%d", v)
	case int16:
		data = fmt.Sprintf("%d", v)
	case int32:
		data = fmt.Sprintf("%d", v)
	case int64:
		data = fmt.Sprintf("%d", v)
	case uint:
		data = fmt.Sprintf("%d", v)
	case uint8:
		data = fmt.Sprintf("%d", v)
	case uint16:
		data = fmt.Sprintf("%d", v)
	case uint32:
		data = fmt.Sprintf("%d", v)
	case uint64:
		data = fmt.Sprintf("%d", v)
	case float32:
		data = fmt.Sprintf("%g", v)
	case float64:
		data = fmt.Sprintf("%g", v)
	default:
		byts, err := json.Marshal(payload)
		if err != nil {
			return err
		}
		data = string(byts)
	}
	fmt.Fprintf(s.w, "data: %s\n\n", data)

	http.NewResponseController(s.w).Flush()
	return nil
}

// Close is a no-op for SSE. We keep the method for compatibility with other
// stream types.
func (s *MonitorServerStream) Close() error {
	return nil
}
