// Code generated by goa v3.20.1, DO NOT EDIT.
//
// sse
//
// Command:
// $ goa gen goa.design/examples/sse/design

package server

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"

	"goa.design/examples/sse/gen/monitor"
)

// MonitorServerStream implements the monitor.MonitorServerStream interface
// using Server-Sent Events.
type MonitorServerStream struct {
	// once ensures the headers are written once.
	once sync.Once
	// w is the HTTP response writer used to send the SSE events.
	w http.ResponseWriter
	// r is the HTTP request.
	r *http.Request
}

// Send Send streams instances of "monitor.Usage" to the "monitor" endpoint SSE
// connection.
func (s *MonitorServerStream) Send(v *monitor.Usage) error {
	return s.SendWithContext(context.Background(), v)
}

// SendWithContext SendWithContext streams instances of "monitor.Usage" to the
// "monitor" endpoint SSE connection with context.
func (s *MonitorServerStream) SendWithContext(ctx context.Context, v *monitor.Usage) error {
	s.once.Do(func() {
		header := s.w.Header()
		if header.Get("Content-Type") == "" {
			header.Set("Content-Type", "text/event-stream")
		}
		if header.Get("Cache-Control") == "" {
			header.Set("Cache-Control", "no-cache")
		}
		if header.Get("Connection") == "" {
			header.Set("Connection", "keep-alive")
		}
		s.w.WriteHeader(http.StatusOK)
	})
	res := v

	var data string
	byts, err := json.Marshal(res)
	if err != nil {
		return err
	}
	data = string(byts)
	fmt.Fprintf(s.w, "data: %s\n\n", data)

	if f, ok := s.w.(http.Flusher); ok {
		f.Flush()
	}
	return nil
}

// Close is a no-op for SSE. We keep the method for compatibility with other
// stream types.
func (s *MonitorServerStream) Close() error {
	return nil
}
