// Code generated by goa v3.0.10, DO NOT EDIT.
//
// upload_download HTTP client CLI support package
//
// Command:
// $ goa gen goa.design/examples/upload_download/design

package cli

import (
	"flag"
	"fmt"
	"net/http"
	"os"

	updownc "goa.design/examples/upload_download/gen/http/updown/client"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// UsageCommands returns the set of commands and sub-commands using the format
//
//    command (subcommand1|subcommand2|...)
//
func UsageCommands() string {
	return `updown (upload|download)
`
}

// UsageExamples produces an example of a valid invocation of the CLI tool.
func UsageExamples() string {
	return os.Args[0] + ` updown upload --name "goa.png" --length 4194304` + "\n" +
		""
}

// ParseEndpoint returns the endpoint and payload as specified on the command
// line.
func ParseEndpoint(
	scheme, host string,
	doer goahttp.Doer,
	enc func(*http.Request) goahttp.Encoder,
	dec func(*http.Response) goahttp.Decoder,
	restore bool,
) (goa.Endpoint, interface{}, error) {
	var (
		updownFlags = flag.NewFlagSet("updown", flag.ContinueOnError)

		updownUploadFlags      = flag.NewFlagSet("upload", flag.ExitOnError)
		updownUploadNameFlag   = updownUploadFlags.String("name", "REQUIRED", "Name is the name of the file being uploaded")
		updownUploadLengthFlag = updownUploadFlags.String("length", "REQUIRED", "")

		updownDownloadFlags = flag.NewFlagSet("download", flag.ExitOnError)
		updownDownloadPFlag = updownDownloadFlags.String("p", "REQUIRED", "string is the payload type of the updown service download method.")
	)
	updownFlags.Usage = updownUsage
	updownUploadFlags.Usage = updownUploadUsage
	updownDownloadFlags.Usage = updownDownloadUsage

	if err := flag.CommandLine.Parse(os.Args[1:]); err != nil {
		return nil, nil, err
	}

	if flag.NArg() < 2 { // two non flag args are required: SERVICE and ENDPOINT (aka COMMAND)
		return nil, nil, fmt.Errorf("not enough arguments")
	}

	var (
		svcn string
		svcf *flag.FlagSet
	)
	{
		svcn = flag.Arg(0)
		switch svcn {
		case "updown":
			svcf = updownFlags
		default:
			return nil, nil, fmt.Errorf("unknown service %q", svcn)
		}
	}
	if err := svcf.Parse(flag.Args()[1:]); err != nil {
		return nil, nil, err
	}

	var (
		epn string
		epf *flag.FlagSet
	)
	{
		epn = svcf.Arg(0)
		switch svcn {
		case "updown":
			switch epn {
			case "upload":
				epf = updownUploadFlags

			case "download":
				epf = updownDownloadFlags

			}

		}
	}
	if epf == nil {
		return nil, nil, fmt.Errorf("unknown %q endpoint %q", svcn, epn)
	}

	// Parse endpoint flags if any
	if svcf.NArg() > 1 {
		if err := epf.Parse(svcf.Args()[1:]); err != nil {
			return nil, nil, err
		}
	}

	var (
		data     interface{}
		endpoint goa.Endpoint
		err      error
	)
	{
		switch svcn {
		case "updown":
			c := updownc.NewClient(scheme, host, doer, enc, dec, restore)
			switch epn {
			case "upload":
				endpoint = c.Upload()
				data, err = updownc.BuildUploadPayload(*updownUploadNameFlag, *updownUploadLengthFlag)
			case "download":
				endpoint = c.Download()
				data = *updownDownloadPFlag
			}
		}
	}
	if err != nil {
		return nil, nil, err
	}

	return endpoint, data, nil
}

// updownUsage displays the usage of the updown command and its subcommands.
func updownUsage() {
	fmt.Fprintf(os.Stderr, `Service updown demonstrates how to implement upload and download of files in
	Goa without having to load the entire content in memory first.
	The upload method uses SkipRequestBodyEncodeDecode to delegate reading the HTTP
	request body to the service logic. This alleviates the need for loading the
	full body content in memory first to decode it into a data structure. Note that
	using SkipRequestBodyDecode is incompatible with gRPC and can only be used on
	methods that only define a HTTP transport mapping. This example implementation
	leverages package "mime/multipart" to read the request body.
	Similarly the download method uses SkipResponseBodyEncodeDecode to stream the 
	file to the client without requiring to load the complete content in memory
	first. As with SkipRequestBodyDecode using SkipResponseBodyEncodeDecode is
	incompatible with gRPC.
Usage:
    %s [globalflags] updown COMMAND [flags]

COMMAND:
    upload: Upload implements upload.
    download: Download implements download.

Additional help:
    %s updown COMMAND --help
`, os.Args[0], os.Args[0])
}
func updownUploadUsage() {
	fmt.Fprintf(os.Stderr, `%s [flags] updown upload -name STRING -length UINT

Upload implements upload.
    -name STRING: Name is the name of the file being uploaded
    -length UINT: 

Example:
    `+os.Args[0]+` updown upload --name "goa.png" --length 4194304
`, os.Args[0])
}

func updownDownloadUsage() {
	fmt.Fprintf(os.Stderr, `%s [flags] updown download -p STRING

Download implements download.
    -p STRING: string is the payload type of the updown service download method.

Example:
    `+os.Args[0]+` updown download --p "Hic accusamus delectus voluptatum architecto."
`, os.Args[0])
}
