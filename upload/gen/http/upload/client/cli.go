// Code generated by goa v3.0.9, DO NOT EDIT.
//
// upload HTTP client CLI support package
//
// Command:
// $ goa gen goa.design/examples/upload/design

package client

import (
	"fmt"
	"strconv"

	upload "goa.design/examples/upload/gen/upload"
	goa "goa.design/goa/v3/pkg"
)

// BuildHeadPayload builds the payload for the upload head endpoint from CLI
// flags.
func BuildHeadPayload(uploadHeadID string, uploadHeadTusResumable string, uploadHeadUploadOffset string) (*upload.HeadPayload, error) {
	var err error
	var id string
	{
		id = uploadHeadID
	}
	var tusResumable string
	{
		tusResumable = uploadHeadTusResumable
	}
	var uploadOffset *uint
	{
		if uploadHeadUploadOffset != "" {
			var v uint64
			v, err = strconv.ParseUint(uploadHeadUploadOffset, 10, 64)
			val := uint(v)
			uploadOffset = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for uploadOffset, must be UINT")
			}
		}
	}
	payload := &upload.HeadPayload{
		ID:           id,
		TusResumable: tusResumable,
		UploadOffset: uploadOffset,
	}
	return payload, nil
}

// BuildPatchPayload builds the payload for the upload patch endpoint from CLI
// flags.
func BuildPatchPayload(uploadPatchBody string, uploadPatchID string, uploadPatchTusResumable string, uploadPatchUploadOffset string, uploadPatchUploadChecksum string) (*upload.PatchPayload, error) {
	var err error
	var body []byte
	{
		body = []byte(uploadPatchBody)
	}
	var id string
	{
		id = uploadPatchID
	}
	var tusResumable string
	{
		tusResumable = uploadPatchTusResumable
	}
	var uploadOffset uint
	{
		var v uint64
		v, err = strconv.ParseUint(uploadPatchUploadOffset, 10, 64)
		uploadOffset = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for uploadOffset, must be UINT")
		}
	}
	var uploadChecksum *string
	{
		if uploadPatchUploadChecksum != "" {
			uploadChecksum = &uploadPatchUploadChecksum
		}
	}
	v := body
	res := &upload.PatchPayload{
		Content: v,
	}
	res.ID = id
	res.TusResumable = tusResumable
	res.UploadOffset = uploadOffset
	res.UploadChecksum = uploadChecksum
	return res, nil
}

// BuildPostPayload builds the payload for the upload post endpoint from CLI
// flags.
func BuildPostPayload(uploadPostBody string, uploadPostTusResumable string, uploadPostUploadLength string, uploadPostUploadDeferLength string, uploadPostUploadChecksum string, uploadPostUploadMetadata string, uploadPostTusMaxSize string) (*upload.PostPayload, error) {
	var err error
	var body []byte
	{
		body = []byte(uploadPostBody)
	}
	var tusResumable string
	{
		tusResumable = uploadPostTusResumable
	}
	var uploadLength *uint
	{
		if uploadPostUploadLength != "" {
			var v uint64
			v, err = strconv.ParseUint(uploadPostUploadLength, 10, 64)
			val := uint(v)
			uploadLength = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for uploadLength, must be UINT")
			}
		}
	}
	var uploadDeferLength *int
	{
		if uploadPostUploadDeferLength != "" {
			var v int64
			v, err = strconv.ParseInt(uploadPostUploadDeferLength, 10, 64)
			val := int(v)
			uploadDeferLength = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for uploadDeferLength, must be INT")
			}
			if uploadDeferLength != nil {
				if !(*uploadDeferLength == 1) {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("uploadDeferLength", *uploadDeferLength, []interface{}{1}))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var uploadChecksum *string
	{
		if uploadPostUploadChecksum != "" {
			uploadChecksum = &uploadPostUploadChecksum
		}
	}
	var uploadMetadata *string
	{
		if uploadPostUploadMetadata != "" {
			uploadMetadata = &uploadPostUploadMetadata
		}
	}
	var tusMaxSize *uint
	{
		if uploadPostTusMaxSize != "" {
			var v uint64
			v, err = strconv.ParseUint(uploadPostTusMaxSize, 10, 64)
			val := uint(v)
			tusMaxSize = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for tusMaxSize, must be UINT")
			}
		}
	}
	v := body
	res := &upload.PostPayload{
		Content: v,
	}
	res.TusResumable = tusResumable
	res.UploadLength = uploadLength
	res.UploadDeferLength = uploadDeferLength
	res.UploadChecksum = uploadChecksum
	res.UploadMetadata = uploadMetadata
	res.TusMaxSize = tusMaxSize
	return res, nil
}

// BuildDeletePayload builds the payload for the upload delete endpoint from
// CLI flags.
func BuildDeletePayload(uploadDeleteID string, uploadDeleteTusResumable string) (*upload.DeletePayload, error) {
	var id string
	{
		id = uploadDeleteID
	}
	var tusResumable string
	{
		tusResumable = uploadDeleteTusResumable
	}
	payload := &upload.DeletePayload{
		ID:           id,
		TusResumable: tusResumable,
	}
	return payload, nil
}
